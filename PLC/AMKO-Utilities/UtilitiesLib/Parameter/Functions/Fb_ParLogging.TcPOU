<<<<<<< Updated upstream
﻿<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.5">
  <POU Name="Fb_ParLogging" Id="{70cb49c5-c474-4a5d-8c59-0231168edf6a}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK PUBLIC Fb_ParLogging EXTENDS FB_ParameterHandler
VAR_OUTPUT
	stParLog		: Udt_ParLog_Old ; // active parameter list
	bReadBusy		: BOOL		:= FALSE	; // File acces Bussy
	bWriteBusy		: BOOL 		:= FALSE	; // file write bussy
	bError			: BOOL		:= FALSE	; // File acces error
	nErrId			: UDINT		:= 0		; // File acces error Id
	nRow	 		: UDINT 	:= 0		;(* Row number (record) *)
	nColumn			: UDINT 	:= 0		;(* Column number (record field) *)
	nInitStep		: UDINT 	:= 0 		; // Initialization step
END_VAR
VAR
	// ====== Compare array =====
		arFileParameters		: ARRAY [0..GVL_Parameters.MAX_PARAMETERS] OF Udt_Parameter;
		nNumberOfParFromFile	: UDINT; // Number of parameters read from file
		nNumberOfChanges		: UDINT; // Number of parameter changes 
		arChangeLog				: ARRAY [0..(GVL_Parameters.MAX_PARAMETERS * 2)] OF STRING ; // Parameter change log 
	// ====== Internal commands ======
		bCmdParFileWrite	: BOOL ; // write alle parameters to .csv file
		bCmdParLogWrite		: BOOL ; // write all changes to .csv file
		bCmdParFileRead		: BOOL ; // Read all parameters from .csv file 
		StParameter			: UDT_Parameter_1 ;
	// ====== File headers ======
		sCsvFileHeader : STRING := 'NUMBER;NAME;TYPE;DISCRIPTION;FACTORY;MAXIMUM;MINIMUM;UNIT;VALUE$L';
	// ====== internal status ======
		bInitOK				: BOOL 	:= FALSE ; // init has been done succesfully
		bFileNotFound		: BOOL 	:= FALSE ; // Parameter file has not been found 
		bParCountDiference	: BOOL 	:= FALSE ; // The number of parameters from file does not match machine 
		bParNumberDiference	: BOOL 	:= FALSE ; // The parameters from file do not match machine
		nDiferenceRow		: UDINT	:= 0	 ; // The file array row number in which diferences were found
 
	// ====== Current step =====
		nReadStep			: INT 	:= 0 	; // File read stepper
		nLogStep			: INT 	:= 0 	; // File logging step
		nWriteStep			: INT 	:= 0 	; // File Write stepper

	// ====== Read variables ======
		hFile				: UINT	:= 0;(* File handle of the source file *)
		cbField				: UDINT	;(* Number of bytes in field buffer *)

	// ====== Read variables ======
		sCSVLine			: T_MaxString := '';(* Single CSV text line (row, record), we are using string as record buffer (your are able to see created fields) *)
		sCSVField			: T_MaxString := '';(* Single CSV field value (column, record field) *)
		sCSVFieldString		: T_MaxString := '';// CSV field converted into string
	// ====== Functions ======
		fbFileOpenForRead	: FB_FileOpen	;(* Opens file *)
		fbFileOpenForWrite	: FB_FileOpen	;(* Opens file *)
		fbFileOpenForLog	: FB_FileOpen	;(* Opens file *)
		fbFileClose			: FB_FileClose	;(* Closes file *)
		fbFileGets			: FB_FileGets	;(* Reads one record (line) *)
		fbFilePuts			: FB_FilePuts	;(* Writes one record (line) *)
		fbReader			: FB_CSVMemBufferReader;(* Helper function block used to parse CSV data bytes (single record line) *)
		fbWriter			: FB_CSVMemBufferWriter;(* Helper function block used to create CSV data bytes (single record line) *)
	
	// Par Read timeout 
		TonParWriteTimeout	: TON := (PT := T#5S) ; // Timeout for parameter read
		TonParreadTimeout	: TON := (PT := T#5S) ; // Timeout for parameter read
		
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[SUPER^();

// ===== init =====
	IF NOT binitok THEN 
		RETURN;
	ELSE 
		CmdParWriteToFile();
		CmdParLoadFromFile();
	END_IF
	]]></ST>
    </Implementation>
    <Folder Name="Private" Id="{4ef361fb-7879-4d00-8723-9a400aa8a5ef}" />
    <Method Name="CmdParLoadFromFile" Id="{5fca42a6-0210-4da3-921b-30c71fd4a2e1}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE CmdParLoadFromFile : BOOL
VAR_INPUT
END_VAR
VAR 
	i : UDINT ;
	fTempValue	: LREAL ; // Tomporary value to be placed in save value
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ExecFileRead() THEN 
	;
ELSE
	RETURN;
END_IF

// Compare Parameter counters 
IF nNumberOfParameters <> nNumberOfParFromFile THEN
	bParCountDiference := TRUE ;
ELSE 
	bParCountDiference := FALSE ;
END_IF

// Compare Parameter from file with parameters in machine then write from file to machine
bParNumberDiference := FALSE ;
nDiferenceRow		:= 0 ;
IF NOT bParCountDiference THEN 
	FOR i := 0 TO nNumberOfParameters DO
		IF arParameters[i].nNumber <> arFileParameters[i].nNumber THEN
			bParNumberDiference := TRUE ;
			nDiferenceRow		:= i ;
			CONTINUE;
		ELSE
			IF arParameters[i].pParameter^.fValue <> arFileParameters[i].fValue THEN 
				fTempValue := arParameters[i].pParameter^.fValue;  
			ELSE
				fTempValue := 0;
			END_IF
			arParameters[i].pParameter^			:= arFileParameters[i];
			arParameters[i].pParameter^.fSaved 	:= fTempValue;
		END_IF
	END_FOR
END_IF 

CmdParLoadFromFile := TRUE ;]]></ST>
      </Implementation>
    </Method>
    <Method Name="CmdParWriteToFile" Id="{aa854d64-1120-4bd0-ad5a-36d498335059}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE CmdParWriteToFile : BOOL
VAR_INPUT
END_VAR
VAR
	i : UDINT ;
	sDTString : STRING ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF bCmdParFileWrite THEN 
	FOR i := 0 TO nNumberOfParameters DO
(*			IF 	NOT bFileNotFound AND
				(arFileParameters[i].fValue <> arParameters[i].pParameter^.fValue OR
				arFileParameters[i].fFactory <> arParameters[i].pParameter^.fFactory) THEN
					sDTString := DT_TO_STRING(Sys_Variables.SystemTime);
					sDTString := STRING_TO_CSVFIELD(sdtstring,TRUE);
					arChangeLog[nNumberOfChanges*2] := CONCAT(sDTString,F_ParToCsvLine( arFileParameters[i],));
					arChangeLog[(nNumberOfChanges*2)+1] := CONCAT( ';', STR2 := F_ParToCsvLine( arParameters[i].pParameter^)); 
					bCmdParLogWrite 	:= TRUE ;
					nNumberOfChanges	:= LIMIT(0,nNumberOfChanges + 1, nNumberOfParameters); 
			END_IF 
*)
			// Save current actual value for later restore
			IF arParameters[i].pParameter^.fValue <> arFileParameters[i].fValue THEN
				arParameters[i].pParameter^.fSaved := arFileParameters[i].fValue ;
			END_IF
			arFileParameters[i] := arParameters[i].pParameter^ ;
	END_FOR
END_IF

//IF nNumberOfChanges > 0 AND NOT bParCountDiference THEN 
//	ExecWriteToLog();
//END_IF
CmdParWriteToFile := ExecFileWrite();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="CmdSavePar" Id="{bbcba8cc-bd94-4323-bfac-4059573c8d29}">
      <Declaration><![CDATA[METHOD PUBLIC CmdSavePar : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[bCmdParFileWrite := TRUE ;

CmdSavePar := bWriteBusy ;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecFileRead" Id="{667e0f14-aa11-404d-9b7f-8790b7d6f1b6}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE ExecFileRead : BOOL
VAR_INPUT
END_VAR
VAR
	i : UDINT := 0 ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ===== Wait for command =====
	IF bCmdParFileRead OR bReadBusy THEN 
		;
	ELSE
		RETURN ;
	END_IF

// ===== prepare for file read =====
	CASE nReadStep OF
		0:	(* Wait for rising edge at bRead variable *)
			bReadBusy		:= TRUE;
			bFileNotFound	:= FALSE ;
			bCmdParFileRead := FALSE ;
			bError			:= FALSE;
			nErrId			:= 0;
			hFile			:= 0;
			nRow			:= 0;
			nColumn			:= 0;
			nReadStep 			:= 1;
	
		1:	(* Open source file *)
			fbFileOpenForRead(  bExecute := FALSE  );
			fbFileOpenForRead( sNetId := GVL_Parameters.sNetId, sPathName := GVL_Parameters.sPARLIST_FILE, nMode := FOPEN_MODEREAD OR FOPEN_MODETEXT,(* Open file in text mode! *)
						ePath := PATH_GENERIC, bExecute := TRUE );
			nReadStep := 2;
	
		2:(* Wait until open not busy *)
			fbFileOpenForRead( bExecute := FALSE, bError => bError, nErrID => nErrID, hFile => hFile );
			IF NOT fbFileOpenForRead.bBusy THEN
				IF NOT fbFileOpenForRead.bError THEN
					nReadStep := 3;
				ELSE(* Error: file not found? *)
					bFileNotFound := TRUE ;
					nReadStep := 100;
				END_IF
			END_IF
		3:	(* Read single line (record) *)
			fbFileGets( bExecute := FALSE );
			fbFileGets( sNetId := GVL_Parameters.sNetId, hFile := hFile, bExecute := TRUE );
			nReadStep := 4;
		4:(* Wait until read not busy *)
			fbFileGets( bExecute := FALSE, bError => bError, nErrID => nErrID, sLine => sCSVLine );
			IF NOT fbFileGets.bBusy THEN
				IF NOT fbFileGets.bError THEN
					IF fbFileGets.bEOF THEN
						nReadStep 				:= 10;(* End of file reached => Close source file *)
					ELSE
						(* FB_FileGets returns text line without the CR (carriage return) character.
						We have to restore the CR character (replace the $L character with $R$L characters) *)
						IF RIGHT( sCSVLine, 1 ) = '$L' THEN
							sCSVLine := REPLACE( sCSVLine, '$R$L', 2, LEN( sCSVLine ) );
						END_IF
						nReadStep := 5;
					END_IF
				ELSE(* Error *)
					nReadStep := 100;
				END_IF
			END_IF
		5:(* Parse single line (record) *)
			fbReader.eCmd := eEnumCmd_First;(* Read first field value *)
			REPEAT
				fbReader( pBuffer := ADR( sCSVLine ), cbBuffer := SIZEOF( sCSVLine ), getValue => sCSVField );
				IF fbReader.bOk THEN
					fbReader.eCmd := eEnumCmd_Next;(* Read next field value *)
					IF ( nRow <= GVL_Parameters.MAX_PARAMETERS ) AND nRow > 0 THEN
						IF ( nColumn <= GVL_Parameters.PAR_COLUMNS ) THEN
							i	:= nRow - 1;
							sCSVFieldString	:= CSVFIELD_TO_STRING( sCSVField, TRUE);
							CASE nColumn OF
									0: // Parameter number [Udint]	
										arFileParameters[i].nNumber		:= STRING_TO_UDINT(sCSVFieldString); 						
									1: // Parameter Name [string]
										arFileParameters[i].sName 		:= sCSVFieldString;							
									2: // Parameter type [String]
										arFileParameters[i].sType 		:= sCSVFieldString;	
									3: // Parameter discription [string]
										arFileParameters[i].sDiscription:= sCSVFieldString;						
									4: // Parameter factory value [LREAL]
										arFileParameters[i].fFactory	:= STRING_TO_LREAL(sCSVFieldString);							
									5: // Parameter maximum value [LREAL]
										arFileParameters[i].fMaximum	:= STRING_TO_LREAL(sCSVFieldString);							
									6: // Parameter minimum value[LREAL]
										arFileParameters[i].fMinimum	:= STRING_TO_LREAL(sCSVFieldString);							
									7: // Parameter unit {String]
										arFileParameters[i].sUnit 		:= sCSVFieldString;							
									8: // Parameter value [LREAL]
										arFileParameters[i].fValue		:= STRING_TO_LREAL(sCSVFieldString);							
							ELSE
								;
							END_CASE
						END_IF
					END_IF
					nColumn := nColumn + 1;(* Increment number of read columns *)
					IF fbReader.bCRLF THEN(* CRLF == TRUE => End of reacord reached *)
						nNumberOfParFromFile := nRow;
						nRow 		:= nRow + 1;(* Increment number of read records *)
						nColumn 	:= 0;(* Reset number of columns *)
					END_IF
				ELSE(* Error: End of record reached or all fields read *)
					nReadStep := 3;(* Try to read next line *)
				END_IF
			UNTIL NOT fbReader.bOk
			END_REPEAT
		10:	(* Close source file *)
			fbFileClose( bExecute := FALSE );
			fbFileClose( sNetId := GVL_Parameters.sNetId, hFile := hFile, bExecute := TRUE );
			nReadStep := 11;
	
		11:(* Wait until close not busy *)
			fbFileClose( bExecute := FALSE, bError => bError, nErrID => nErrID );
			IF ( NOT fbFileClose.bBusy ) THEN
				hFile := 0;
				nReadStep := 100;
			END_IF
		100: (* Error or ready nReadStep => cleanup *)
			IF ( hFile <> 0 ) THEN
				nReadStep := 10; (* Close the source file *)
			ELSE
				bReadBusy := FALSE;
				ExecFileRead := TRUE ;
				nReadStep := 0;	(* Ready *)
			END_IF
	END_CASE
	
	TonParreadTimeout(IN := bReadBusy);
	bError S= TonParreadTimeout.Q;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecFileWrite" Id="{4f304946-cc76-469f-a7d8-a3de4893dd6a}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD INTERNAL ExecFileWrite : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ===== Wait for command =====
	IF bCmdParFileWrite OR bWriteBusy THEN 
		;
	ELSE
		RETURN ;
	END_IF

// ===== Start file write =====
	CASE nWriteStep OF
		0:	(* Wait for rising edge at bWrite variable *)
				bFileNotFound		:= FALSE ;
				bParCountDiference	:= FALSE ;
				bWriteBusy 			:= TRUE;
				bCmdParFileWrite	:= FALSE ;
				bError				:= FALSE;
				nErrId				:= 0;
				hFile				:= 0;
				nRow				:= 0;
				nWriteStep 				:= 1;
		1:	(* Open source file *)
			fbFileOpenForWrite(  bExecute := FALSE  );
			fbFileOpenForWrite( sNetId := GVL_Parameters.sNetId, sPathName := GVL_Parameters.sPARLIST_FILE, nMode := FOPEN_MODEWRITE OR FOPEN_MODETEXT,(* Open file in TEXT mode! *)
						ePath := PATH_GENERIC, bExecute := TRUE );
			nWriteStep := 2;
		2:(* Wait until open not busy *)
			fbFileOpenForWrite( bExecute := FALSE, bError => bError, nErrID => nErrID, hFile => hFile );
			IF NOT fbFileOpenForWrite.bBusy THEN
				IF NOT fbFileOpenForWrite.bError THEN
					nWriteStep := 3;
				ELSE(* Error: file not found? *)
					nWriteStep := 100;
				END_IF
			END_IF
	
		3:(* Convert one PLC record to CSV format *)
			IF nRow = 0 THEN 
				sCSVLine := sCsvFileHeader;
			ELSE
				sCSVLine := F_ParToCsvLine(stParameter := arFileParameters[nRow - 1], nColumn := nColumn);
			END_IF
			nWriteStep := 4 ;
		4:	(* Write single Field *)
			fbFilePuts( bExecute := FALSE );
			fbFilePuts( sNetId := GVL_Parameters.sNetId, hFile := hFile, sLine := sCSVLine, bExecute := TRUE );
			nWriteStep := 5;
		5:(* Wait until write not busy *)
			fbFilePuts( bExecute := FALSE, bError => bError, nErrID => nErrID );
			IF NOT fbFilePuts.bBusy THEN
				IF nRow = nNumberOfParameters + 1 THEN
					nWriteStep := 10;
				ELSIF NOT fbFilePuts.bError THEN
					nWriteStep := 3;(* Write next record *)
					IF nRow = 0 OR nColumn = 8 THEN
						nColumn := 0 ;
						nRow := nRow + 1;
					ELSE
						nColumn := nColumn + 1;
					END_IF
				ELSE(* Error *)
					nWriteStep := 100;
				END_IF
			END_IF
		10:	(* Close source file *)
			fbFileClose( bExecute := FALSE );
			fbFileClose( sNetId := GVL_Parameters.sNetId, hFile := hFile, bExecute := TRUE );
			nWriteStep := 11;
	
		11:(* Wait until close not busy *)
			fbFileClose( bExecute := FALSE, bError => bError, nErrID => nErrID );
			IF ( NOT fbFileClose.bBusy ) THEN
				hFile := 0;
				nWriteStep := 100;
			END_IF
	
		100: (* Error or ready nWriteStep => cleanup *)
			IF ( hFile <> 0 ) THEN
				nWriteStep := 10; (* Close the source file *)
			ELSE
				bParCountDiference 	:= FALSE ;
				bWriteBusy 			:= FALSE;
				ExecFileWrite		:= TRUE ;
				nWriteStep 			:= 0;	(* Ready *)
			END_IF
	
	END_CASE
	
	TonParWriteTimeout(IN := bWriteBusy);
	bError	S= TonParWriteTimeout.Q ;
	

ExecFileWrite := TRUE ;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExecWriteToLog" Id="{236b4ab3-7a1a-442f-8443-9a38dfaf49dc}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE ExecWriteToLog : BOOL
VAR_INPUT
END_VAR
VAR
	sTempField : STRING ;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ===== Wait for command =====
	IF bWriteBusy OR bCmdParLogWrite THEN 
		;
	ELSE
		RETURN ;
	END_IF

// ===== Start file write =====
CASE nLogStep OF
	0:	(* Wait for rising edge at bWrite variable *)
			bWriteBusy 			:= TRUE;
			bCmdParLogWrite	:= FALSE ;
			bError				:= FALSE;
			nErrId				:= 0;
			hFile				:= 0;
			nRow				:= nNumberOfChanges * 2; // Twice the number of changes because old and new values are stored sequentially in teh same array
			nLogStep 			:= 1;
	1:	(* Open source file *)
		fbFileOpenForLog(  bExecute := FALSE  );
		fbFileOpenForLog( sNetId := GVL_Parameters.sNetId, sPathName := GVL_Parameters.sPARLIST_FILE, nMode := FOPEN_MODETEXT,(* Open file in TEXT mode! *)
					ePath := PATH_GENERIC, bExecute := TRUE );
		nLogStep := 2;
	2:(* Wait until open not busy *)
		fbFileOpenForLog( bExecute := FALSE, bError => bError, nErrID => nErrID, hFile => hFile );
		IF NOT fbFileOpenForLog.bBusy THEN
			IF NOT fbFileOpenForLog.bError THEN
				nLogStep := 3;
			ELSE(* Error: file not found? *)
				nLogStep := 100;
			END_IF
		END_IF

	3:(* Convert one PLC record to CSV format *)
		sCSVLine := arChangeLog[nRow];
		nLogStep := 4 ;
	4:	(* Write single text line *)
		fbFilePuts( bExecute := FALSE );
		fbFilePuts( sNetId := GVL_Parameters.sNetId, hFile := hFile, sLine := sCSVLine, bExecute := TRUE );
		nLogStep := 5;

	5:(* Wait until write not busy *)
		fbFilePuts( bExecute := FALSE, bError => bError, nErrID => nErrID );
		IF NOT fbFilePuts.bBusy THEN
			IF nRow = 0 THEN
				nNumberOfChanges := 0;
				nLogStep := 10;
			ELSIF NOT fbFilePuts.bError THEN
				arChangeLog[nRow] := ''; // Delete change from log
				nRow := nRow - 1;
				nLogStep := 3;(* Write next record *)
			ELSE(* Error *)
				nLogStep := 100;
			END_IF
		END_IF
	10:	(* Close source file *)
		fbFileClose( bExecute := FALSE );
		fbFileClose( sNetId := GVL_Parameters.sNetId, hFile := hFile, bExecute := TRUE );
		nLogStep := 11;

	11:(* Wait until close not busy *)
		fbFileClose( bExecute := FALSE, bError => bError, nErrID => nErrID );
		IF ( NOT fbFileClose.bBusy ) THEN
			hFile := 0;
			nLogStep := 100;
		END_IF

	100: (* Error or ready nLogStep => cleanup *)
		IF ( hFile <> 0 ) THEN
			nLogStep := 10; (* Close the source file *)
		ELSE
			bWriteBusy := FALSE;
			nLogStep := 0;	(* Ready *)
		END_IF
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Init" Id="{e3729afd-d9ab-4f85-a26c-897c677d5301}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PUBLIC Init : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Read parameters from .CSV file and check if load is valid

CASE nInitStep OF 
	0: //check if init has been done 
		bInitOK 	:= FALSE;
		nInitStep 	:= 10 ;
	10: // start File read
		bCmdParFileRead := TRUE ;
		nInitStep := 11; 
	11: // Execute file read 
		IF CmdParLoadFromFile() THEN 
			nInitStep := 12 ;
		END_IF
	12: // Check if read is valid 
		IF bFileNotFound OR bParCountDiference THEN 
			nInitStep := 20 ;
		ELSE 
			nInitStep := 100 ;
		END_IF
	20: // start File write
		bCmdParFileWrite:= TRUE ;
		nInitStep		:= 21 ;
	21: // Wait for file write to finish
		IF CmdParWriteToFile() THEN 
			nInitStep := 100 ;
		ELSIF bError THEN 
			nInitStep := 900 ; 
		END_IF 
	100: // Init ok 
		bInitOK 	:= TRUE ;
		Init		:= TRUE ;
		nInitStep	:= 0 ;
	900: // file fault	
		bInitOK := FALSE ;
		RETURN ;
	ELSE 
		;
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="Fb_ParLogging">
      <LineId Id="464" Count="0" />
      <LineId Id="544" Count="3" />
      <LineId Id="549" Count="0" />
      <LineId Id="553" Count="0" />
      <LineId Id="551" Count="0" />
      <LineId Id="548" Count="0" />
      <LineId Id="387" Count="0" />
    </LineIds>
    <LineIds Name="Fb_ParLogging.CmdParLoadFromFile">
      <LineId Id="91" Count="0" />
      <LineId Id="143" Count="0" />
      <LineId Id="93" Count="2" />
      <LineId Id="158" Count="0" />
      <LineId Id="108" Count="2" />
      <LineId Id="112" Count="6" />
      <LineId Id="167" Count="0" />
      <LineId Id="119" Count="14" />
      <LineId Id="160" Count="0" />
      <LineId Id="135" Count="0" />
      <LineId Id="44" Count="0" />
    </LineIds>
    <LineIds Name="Fb_ParLogging.CmdParWriteToFile">
      <LineId Id="100" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="49" Count="1" />
      <LineId Id="83" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="55" Count="1" />
      <LineId Id="118" Count="0" />
      <LineId Id="107" Count="2" />
      <LineId Id="111" Count="0" />
      <LineId Id="57" Count="2" />
      <LineId Id="91" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="75" Count="1" />
      <LineId Id="63" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Fb_ParLogging.CmdSavePar">
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="6" Count="0" />
    </LineIds>
    <LineIds Name="Fb_ParLogging.ExecFileRead">
      <LineId Id="9" Count="2" />
      <LineId Id="14" Count="7" />
      <LineId Id="56" Count="0" />
      <LineId Id="22" Count="5" />
      <LineId Id="30" Count="13" />
      <LineId Id="152" Count="0" />
      <LineId Id="44" Count="2" />
      <LineId Id="62" Count="3" />
      <LineId Id="67" Count="6" />
      <LineId Id="75" Count="4" />
      <LineId Id="81" Count="13" />
      <LineId Id="137" Count="0" />
      <LineId Id="140" Count="0" />
      <LineId Id="96" Count="1" />
      <LineId Id="136" Count="0" />
      <LineId Id="101" Count="3" />
      <LineId Id="164" Count="1" />
      <LineId Id="107" Count="9" />
      <LineId Id="120" Count="0" />
      <LineId Id="122" Count="5" />
      <LineId Id="158" Count="0" />
      <LineId Id="128" Count="7" />
      <LineId Id="141" Count="10" />
      <LineId Id="47" Count="4" />
      <LineId Id="188" Count="0" />
      <LineId Id="52" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="181" Count="0" />
      <LineId Id="183" Count="2" />
      <LineId Id="180" Count="0" />
    </LineIds>
    <LineIds Name="Fb_ParLogging.ExecFileWrite">
      <LineId Id="125" Count="2" />
      <LineId Id="130" Count="6" />
      <LineId Id="276" Count="1" />
      <LineId Id="137" Count="5" />
      <LineId Id="144" Count="5" />
      <LineId Id="151" Count="10" />
      <LineId Id="241" Count="0" />
      <LineId Id="204" Count="0" />
      <LineId Id="242" Count="3" />
      <LineId Id="205" Count="3" />
      <LineId Id="210" Count="2" />
      <LineId Id="247" Count="1" />
      <LineId Id="213" Count="1" />
      <LineId Id="253" Count="0" />
      <LineId Id="258" Count="0" />
      <LineId Id="246" Count="0" />
      <LineId Id="254" Count="0" />
      <LineId Id="256" Count="0" />
      <LineId Id="255" Count="0" />
      <LineId Id="215" Count="3" />
      <LineId Id="220" Count="15" />
      <LineId Id="262" Count="0" />
      <LineId Id="236" Count="0" />
      <LineId Id="278" Count="0" />
      <LineId Id="237" Count="3" />
      <LineId Id="269" Count="0" />
      <LineId Id="271" Count="1" />
      <LineId Id="270" Count="0" />
      <LineId Id="274" Count="1" />
      <LineId Id="273" Count="0" />
    </LineIds>
    <LineIds Name="Fb_ParLogging.ExecWriteToLog">
      <LineId Id="6" Count="32" />
      <LineId Id="42" Count="0" />
      <LineId Id="44" Count="9" />
      <LineId Id="88" Count="0" />
      <LineId Id="54" Count="1" />
      <LineId Id="89" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="58" Count="22" />
      <LineId Id="82" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Fb_ParLogging.Init">
      <LineId Id="5" Count="0" />
      <LineId Id="80" Count="2" />
      <LineId Id="123" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="89" Count="3" />
      <LineId Id="129" Count="0" />
      <LineId Id="94" Count="2" />
      <LineId Id="101" Count="0" />
      <LineId Id="103" Count="1" />
      <LineId Id="102" Count="0" />
      <LineId Id="105" Count="0" />
      <LineId Id="107" Count="3" />
      <LineId Id="113" Count="2" />
      <LineId Id="112" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="98" Count="2" />
      <LineId Id="97" Count="0" />
      <LineId Id="116" Count="1" />
      <LineId Id="120" Count="1" />
      <LineId Id="83" Count="0" />
      <LineId Id="26" Count="0" />
    </LineIds>
  </POU>
=======
﻿<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.2">
  <POU Name="Fb_ParLogging" Id="{95121cc7-a75e-41c0-a774-30220739dd9e}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK PUBLIC Fb_ParLogging
VAR_OUTPUT
	stParLog		: Udt_ParLog ; // active parameter list
	bReadBusy		: BOOL		:= FALSE	; // File acces Bussy
	bWriteBusy		: BOOL 		:= FALSE	; // file write bussy
	bFryRead		: BOOL 		:= FALSE	; // File read done
	bFryWrite		: BOOL 		:= FALSE 	; // File Write Done 
	bError			: BOOL		:= FALSE	; // File acces error
	nErrId			: UDINT		:= 0		; // File acces error Id
	bValid 			: BOOL 		:= 0 		; // file write valid
	nRow	 		: UDINT 	:= 0		;(* Row number (record) *)
	nColumn			: UDINT 	:= 0	;(* Column number (record field) *)
END_VAR
VAR
	// ====== Internal commands ======
		bCmdWriteAllPar		: BOOL ;
		bCmdReadAllPar		: BOOL ; 
		StParameter			: Udt_Parameter ;
		
	// ====== internal status ======
		bInitDone			: BOOL := FALSE ; // Init has been done  	
	// ====== Current step =====
		Step				: INT 	:= 0 	; // write action stepper
	
	// ====== Read variables ======
		hFile				: UINT	:= 0;(* File handle of the source file *)
		cbDone				: UDINT := 0;(* Counts allready parsed data bytes *)
		record				: ARRAY[0..1024] OF BYTE;(* Binary row data buffer. The size of this buffer have to be > length of longest record line + 2 (CRLF)  *)
		cbRecord			: UDINT := 0;(* Number of bytes in row buffer *)
		cbField				: UDINT	;(* Number of bytes in field buffer *)

	// ====== Write variables ======
		sParameterString	: ARRAY [0..Param_Settings.PAR_COLUMNS] OF STRING (Param_Settings.MAX_CSV_FIELD_LENGTH); (* temporary parameter buffer to string*)
		sCSVLine			: T_MaxString := '';(* Single CSV text line (row, record), we are using string as record buffer (your are able to see created fields) *)
		sCSVField			: T_MaxString := '';(* Single CSV field value (column, record field) *)
		
	// ====== Functions ======
		fbFileOpen		: FB_FileOpen	;(* Opens file *)
		fbFileClose		: FB_FileClose	;(* Closes file *)
		fbFileGets		: FB_FileGets	;(* Reads one record (line) *)
		fbFilePuts		: FB_FilePuts	;(* Writes one record (line) *)
		fbReader		: FB_CSVMemBufferReader;(* Helper function block used to parse CSV data bytes (single record line) *)
		fbWriter		: FB_CSVMemBufferWriter;(* Helper function block used to create CSV data bytes (single record line) *)
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// ===== init =====
	IF NOT bInitDone THEN 
		Init();
	END_IF

// ===== Read parameters ====
	Mod_CSVFileRead();

// ====== Write parameter(s) to .csv ======
	Mod_CSVFileWrite();  
]]></ST>
    </Implementation>
    <Folder Name="Private" Id="{56a17603-1cd7-4a67-b512-d9bb3d069c77}" />
    <Method Name="Init" Id="{363a503b-c7e7-4e6d-9f1a-c5f8c7b9c544}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PUBLIC Init : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Read parameters from .CSV file
	bCmdReadAllPar := TRUE ;

	IF bReadBusy THEN
		bInitDone := TRUE ;
	END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Mod_BackupPar" Id="{c91b9957-fd7c-4ec0-b6ae-57a6fb115345}">
      <Declaration><![CDATA[METHOD PUBLIC Mod_BackupPar : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ====== Set parameter write command ======
	IF NOT bWriteBusy AND NOT bReadBusy AND NOT bError THEN 
		bCmdWriteAllPar 	:= TRUE 	;
		Mod_BackupPar 		:= FALSE 	;	
	ELSE 
		Mod_BackupPar 	:= TRUE 	;	
	END_IF
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="Mod_ChangePar" Id="{11747ab0-b699-46d1-8fe3-5992be5dc05a}">
      <Declaration><![CDATA[METHOD Mod_ChangePar : BOOL
VAR_INPUT
	stInputParameter 	: Udt_Parameter_New ; // input parameter to be changed	
	i					: UDINT			; // index number of parameter
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// write parameter to log
	IF NOT bWriteBusy AND NOT bReadBusy THEN 
		i 			:= stInputParameter.IndexNumber ; // check index number
		IF i <= Param_Settings.MAX_PARAMETERS THEN
			stParLog.ParList[i] 	:= stInputParameter ;
		END_IF
	END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Mod_CSVFileRead" Id="{8d2d3c4c-6e8f-4453-89d4-447ba4390d9f}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE Mod_CSVFileRead : BOOL
VAR_INPUT
END_VAR
VAR
	i : UDINT ; // index number
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ===== Wait for command =====
	IF bReadBusy THEN 
		;
	ELSIF bCmdReadAllPar THEN
		;
	ELSE
		RETURN ;
	END_IF

// ===== prepare for file read =====
CASE step OF
	0:	(* Wait for rising edge at bRead variable *)
		bReadBusy		:= TRUE;
		bCmdReadAllPar 	:= FALSE ;
		bError			:= FALSE;
		nErrId			:= 0;
		hFile			:= 0;
		nRow			:= 1;
		nColumn			:= 0;
		cbRecord		:= 0;
		cbDone 			:= 0;
		step 			:= 1;

	1:	(* Open source file *)
		fbFileOpen(  bExecute := FALSE  );
		fbFileOpen( sNetId := Param_Settings.sNetId, sPathName := Param_Settings.sPARLIST_FILE, nMode := FOPEN_MODEREAD OR FOPEN_MODETEXT,(* Open file in text mode! *)
					ePath := PATH_GENERIC, bExecute := TRUE );
		step := 2;

	2:(* Wait until open not busy *)
		fbFileOpen( bExecute := FALSE, bError => bError, nErrID => nErrID, hFile => hFile );
		IF NOT fbFileOpen.bBusy THEN
			IF NOT fbFileOpen.bError THEN
				step := 3;
			ELSE(* Error: file not found? *)
				step := 100;
			END_IF
		END_IF

	3:	(* Read single line (record) *)
		fbFileGets( bExecute := FALSE );
		fbFileGets( sNetId := Param_Settings.sNetId, hFile := hFile, bExecute := TRUE );
		step := 4;

	4:(* Wait until read not busy *)
		fbFileGets( bExecute := FALSE, bError => bError, nErrID => nErrID, sLine => sCSVLine );
		IF NOT fbFileGets.bBusy THEN
			IF NOT fbFileGets.bError THEN
				IF fbFileGets.bEOF THEN
					step := 10;(* End of file reached => Close source file *)
				ELSE

					(* FB_FileGets returns text line without the CR (carriage return) character.
					We have to restore the CR character (replace the $L character with $R$L characters) *)
					IF RIGHT( sCSVLine, 1 ) = '$L' THEN
						sCSVLine := REPLACE( sCSVLine, '$R$L', 2, LEN( sCSVLine ) );
					END_IF

					step := 5;
				END_IF
			ELSE(* Error *)
				step := 100;
			END_IF
		END_IF

	5:(* Parse single line (record) *)
		fbReader.eCmd := eEnumCmd_First;(* Read first field value *)
		REPEAT
			fbReader( pBuffer := ADR( sCSVLine ), cbBuffer := SIZEOF( sCSVLine ), getValue => sCSVField );
			IF fbReader.bOk THEN
				fbReader.eCmd := eEnumCmd_Next;(* Read next field value *)
				IF ( nRow <= Param_Settings.MAX_PARAMETERS ) THEN
					IF ( nColumn <= Param_Settings.PAR_COLUMNS ) THEN

						CASE nColumn OF
								0: // Index number for array [UDINT]							
									i						:= STRING_TO_UDINT(CSVFIELD_TO_STRING( sCSVField, FALSE ));(* TODO: Save or use the field value in your application *) 
									stParLog.ParList[i].IndexNumber	:= i ; 	
									stParLog.ParList[i].bActive		:= TRUE ;						
								1: // Number [int]
									stParLog.ParList[i].Number 		:= STRING_TO_INT(CSVFIELD_TO_STRING( sCSVField, FALSE ));(* TODO: Save or use the field value in your application *)							
								2: // Name [String]
									stParLog.ParList[i].Name 		:= CSVFIELD_TO_STRING( sCSVField, FALSE );(* TODO: Save or use the field value in your application *)							
								3: // Par_Type E_paramterType [INT]
									stParLog.ParList[i].Par_TYPE	:= CSVFIELD_TO_STRING( sCSVField, FALSE );(* TODO: Save or use the field value in your application *)							
								4: // Discription [String]
									stParLog.ParList[i].Discription	:= CSVFIELD_TO_STRING( sCSVField, FALSE );(* TODO: Save or use the field value in your application *)							
								5: // Factory Value [LREAL]
									stParLog.ParList[i].Factory		:= STRING_TO_LREAL(CSVFIELD_TO_STRING( sCSVField, FALSE ));(* TODO: Save or use the field value in your application *)							
								6: // Maximum value [LREAL]
									stParLog.ParList[i].Maximum		:= STRING_TO_LREAL(CSVFIELD_TO_STRING( sCSVField, FALSE ));(* TODO: Save or use the field value in your application *)							
								7: // Minimum Value {LREAL]
									stParLog.ParList[i].Minimum 	:= STRING_TO_LREAL(CSVFIELD_TO_STRING( sCSVField, FALSE ));(* TODO: Save or use the field value in your application *)							
								8: // Unit	{String]
									stParLog.ParList[i].Unit		:= CSVFIELD_TO_STRING( sCSVField, FALSE );(* TODO: Save or use the field value in your application *)							
								9: // Value [LREAL]
									stParLog.ParList[i].Value 		:= STRING_TO_LREAL(CSVFIELD_TO_STRING( sCSVField, FALSE ));(* TODO: Save or use the field value in your application *)							
								10: // Saved {LREAL]	
									stParLog.ParList[i].Saved		:= STRING_TO_LREAL(CSVFIELD_TO_STRING( sCSVField, FALSE ));(* TODO: Save or use the field value in your application *)							
						ELSE
							;
						END_CASE
					END_IF
				END_IF
				nColumn := nColumn + 1;(* Increment number of read columns *)
				IF fbReader.bCRLF THEN(* CRLF == TRUE => End of reacord reached *)
					nRow 		:= nRow + 1;(* Increment number of read records *)
					nColumn 	:= 0;(* Reset number of columns *)
				END_IF
			ELSE(* Error: End of record reached or all fields read *)
				step := 3;(* Try to read next line *)
			END_IF
		UNTIL NOT fbReader.bOk
		END_REPEAT

	10:	(* Close source file *)
		fbFileClose( bExecute := FALSE );
		fbFileClose( sNetId := Param_Settings.sNetId, hFile := hFile, bExecute := TRUE );
		step := 11;

	11:(* Wait until close not busy *)
		fbFileClose( bExecute := FALSE, bError => bError, nErrID => nErrID );
		IF ( NOT fbFileClose.bBusy ) THEN
			hFile := 0;
			step := 100;
		END_IF

	100: (* Error or ready step => cleanup *)
		IF ( hFile <> 0 ) THEN
			step := 10; (* Close the source file *)
		ELSE
			bReadBusy := FALSE;
			step := 0;	(* Ready *)
		END_IF
END_CASE
		

		]]></ST>
      </Implementation>
    </Method>
    <Method Name="Mod_CSVFileWrite" Id="{15fc4a75-db54-43b1-a1f6-51cd7a8f2575}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE Mod_CSVFileWrite : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ===== Wait for command =====
	IF bWriteBusy THEN 
		;
	ELSIF bCmdWriteAllPar THEN 
		;
	ELSE
		RETURN ;
	END_IF

// ===== Start file write =====
CASE step OF
	0:	(* Wait for rising edge at bWrite variable *)
			bWriteBusy 			:= TRUE;
			bCmdWriteAllPar		:= FALSE ;
			bError				:= FALSE;
			nErrId				:= 0;
			hFile				:= 0;
			nRow				:= 0;
			nColumn				:= 0;
			step 				:= 1;
	1:	(* Open source file *)
		fbFileOpen(  bExecute := FALSE  );
		fbFileOpen( sNetId := Param_Settings.sNetId, sPathName := Param_Settings.sPARLIST_FILE, nMode := FOPEN_MODEWRITE OR FOPEN_MODETEXT,(* Open file in TEXT mode! *)
					ePath := PATH_GENERIC, bExecute := TRUE );
		step := 2;

	2:(* Wait until open not busy *)
		fbFileOpen( bExecute := FALSE, bError => bError, nErrID => nErrID, hFile => hFile );
		IF NOT fbFileOpen.bBusy THEN
			IF NOT fbFileOpen.bError THEN
				step := 3;
			ELSE(* Error: file not found? *)
				step := 100;
			END_IF
		END_IF

	3:(* Convert one PLC record to CSV format *)
		sCSVLine := '';
		fbWriter.eCmd := eEnumCmd_First;(* Write first field value *)
		IF nRow <= Param_Settings.MAX_PARAMETERS THEN
			IF stParLog.ParList[nRow].bActive THEN // check if array row is active if not skip row (save proces time) 
				sParameterString[0] 	:= UDINT_TO_STRING (nRow);
				sParameterString[1] 	:= INT_TO_STRING(stParLog.ParList[nRow].Number);
				sParameterString[2] 	:= stParLog.ParList[nRow].Name;
				sParameterString[3] 	:= stParLog.ParList[nRow].Par_TYPE;
				sParameterString[4] 	:= stParLog.ParList[nRow].Discription;
				sParameterString[5] 	:= LREAL_TO_STRING(stParLog.ParList[nRow].Factory);
				sParameterString[6] 	:= LREAL_TO_STRING(stParLog.ParList[nRow].Maximum);
				sParameterString[7] 	:= LREAL_TO_STRING(stParLog.ParList[nRow].Minimum);
				sParameterString[8] 	:= stParLog.ParList[nRow].Unit;
				sParameterString[9] 	:= LREAL_TO_STRING(stParLog.ParList[nRow].Value);
				sParameterString[10]	:= LREAL_TO_STRING(stParLog.ParList[nRow].Saved);

				FOR nColumn := 0 TO Param_Settings.PAR_COLUMNS BY 1 DO
					sCSVField := STRING_TO_CSVFIELD( sParameterString[nColumn ], FALSE );(* TODO: Get field value from your application *)
	
					(* Add new field to the record buffer *)
					fbWriter( 	pBuffer := ADR( sCSVLine ), cbBuffer := SIZEOF( sCSVLine ) - 1, putValue := sCSVField, pValue := 0, cbValue := 0,
								bCRLF := ( nColumn = Param_Settings.PAR_COLUMNS ) );(* bCRLF == TRUE => Write CRLF after the last field value *)
					IF fbWriter.bOk THEN
						fbWriter.eCmd := eEnumCmd_Next;(* Write next field value *)
					ELSE(* Error *)
						step := 100;
						RETURN;
					END_IF
				END_FOR(* FOR nColumn := 0... *)
	
				(* FB_FilePuts adds allready CR (carriage return) to the written line.
				We have to replace the $R$L characters with $L character to avoid double CR. *)
				IF RIGHT( sCSVLine, 2 ) = '$R$L' THEN
					sCSVLine := REPLACE( sCSVLine, '$L', 2, LEN( sCSVLine ) - 1 );
				END_IF
	
				nRow := nRow + 1;(* Increment number of created records (rows) *)
				step := 4;(* Write record to the file *)
			ELSE 
				nRow := nRow +1 ;(* Increment number of created records (rows) *)
			END_IF							
		ELSE(* All rows written => Close file *)
			step := 10;
		END_IF

	4:	(* Write single text line *)
		fbFilePuts( bExecute := FALSE );
		fbFilePuts( sNetId := Param_Settings.sNetId, hFile := hFile, sLine := sCSVLine, bExecute := TRUE );
		step := 5;

	5:(* Wait until write not busy *)
		fbFilePuts( bExecute := FALSE, bError => bError, nErrID => nErrID );
		IF NOT fbFilePuts.bBusy THEN
			IF NOT fbFilePuts.bError THEN
				step := 3;(* Write next record *)
			ELSE(* Error *)
				step := 100;
			END_IF
		END_IF

	10:	(* Close source file *)
		fbFileClose( bExecute := FALSE );
		fbFileClose( sNetId := Param_Settings.sNetId, hFile := hFile, bExecute := TRUE );
		step := 11;

	11:(* Wait until close not busy *)
		fbFileClose( bExecute := FALSE, bError => bError, nErrID => nErrID );
		IF ( NOT fbFileClose.bBusy ) THEN
			hFile := 0;
			step := 100;
		END_IF

	100: (* Error or ready step => cleanup *)
		IF ( hFile <> 0 ) THEN
			step := 10; (* Close the source file *)
		ELSE
			bWriteBusy := FALSE;
			step := 0;	(* Ready *)
		END_IF

END_CASE



]]></ST>
      </Implementation>
    </Method>
    <Method Name="Mod_ReadAllPar" Id="{f4f748f8-d024-4afa-837b-1134ec514581}">
      <Declaration><![CDATA[METHOD PUBLIC Mod_ReadAllPar : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ====== Set parameter Read command ======
	IF NOT bWriteBusy AND NOT bReadBusy AND NOT bError THEN 
		bCmdReadAllPar 		:= TRUE ;
		Mod_ReadAllPar 		:= FALSE;	
	ELSE 
		Mod_ReadAllPar 		:= TRUE ;	
	END_IF
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="Fb_ParLogging">
      <LineId Id="33" Count="0" />
      <LineId Id="81" Count="2" />
      <LineId Id="85" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="94" Count="0" />
    </LineIds>
    <LineIds Name="Fb_ParLogging.Init">
      <LineId Id="5" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="26" Count="0" />
    </LineIds>
    <LineIds Name="Fb_ParLogging.Mod_BackupPar">
      <LineId Id="11" Count="6" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="Fb_ParLogging.Mod_ChangePar">
      <LineId Id="5" Count="1" />
      <LineId Id="8" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="Fb_ParLogging.Mod_CSVFileRead">
      <LineId Id="295" Count="77" />
      <LineId Id="433" Count="0" />
      <LineId Id="373" Count="12" />
      <LineId Id="432" Count="0" />
      <LineId Id="387" Count="0" />
      <LineId Id="431" Count="0" />
      <LineId Id="389" Count="41" />
      <LineId Id="26" Count="0" />
    </LineIds>
    <LineIds Name="Fb_ParLogging.Mod_CSVFileWrite">
      <LineId Id="179" Count="120" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="Fb_ParLogging.Mod_ReadAllPar">
      <LineId Id="11" Count="2" />
      <LineId Id="18" Count="0" />
      <LineId Id="14" Count="2" />
      <LineId Id="6" Count="0" />
    </LineIds>
  </POU>
>>>>>>> Stashed changes
</TcPlcObject>